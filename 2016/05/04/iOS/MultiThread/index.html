<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="MultiThread"/>




  <meta name="keywords" content="iOS, MultiThread, A Little Boy`s Treasure" />










  <link rel="alternate" href="/atom.xml" title="A Little Boy`s Treasure">




  <link rel="shortcut icon" type="image/x-icon" href="/../public/fav.ico?v=2.6.0" />



<link rel="canonical" href="http://nicreals.com/2016/05/04/iOS/MultiThread/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />






  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> MultiThread - A Little Boy`s Treasure </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">A Little Boy`s Treasure</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">A Little Boy`s Treasure</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          MultiThread
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-05-04
        </span>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Before-Everything"><span class="toc-text">Before Everything</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-barrier-async与线程安全"><span class="toc-text">dispatch_barrier_async与线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD-Timer"><span class="toc-text">GCD Timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步与异步，串行与并行"><span class="toc-text">同步与异步，串行与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSThread-NSOperation-GCD比较"><span class="toc-text">NSThread,NSOperation,GCD比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSThread"><span class="toc-text">NSThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSOperation"><span class="toc-text">NSOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GCD"><span class="toc-text">GCD</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-queue-create"><span class="toc-text">dispatch_queue_create</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#串行队列"><span class="toc-text">串行队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行队列"><span class="toc-text">并行队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Main-Dispatch-Queue"><span class="toc-text">Main Dispatch Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Global-Dispatch-Queue"><span class="toc-text">Global Dispatch Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-set-target-queue"><span class="toc-text">dispatch_set_target_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-after"><span class="toc-text">dispatch_after</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-group"><span class="toc-text">dispatch_group</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-group-notify"><span class="toc-text">dispatch_group_notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-group-wait"><span class="toc-text">dispatch_group_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatch-barrier-async"><span class="toc-text">dispatch_barrier_async</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-apply"><span class="toc-text">dispatch_apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-suspend-amp-dispatch-resume"><span class="toc-text">dispatch_suspend & dispatch_resume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch-once"><span class="toc-text">dispatch_once</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatch-Semaphore"><span class="toc-text">Dispatch Semaphore</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <!-- # MultiThread -->
<blockquote>
<p><a href="http://www.infoq.com/cn/articles/os-x-ios-multithread-technology" target="_blank" rel="external">OS X 和 iOS 中的多线程技术</a></p>
<p><a href="https://bestswifter.com/multithreadconclusion/" target="_blank" rel="external">iOS多线程编程——GCD与NSOperation总结</a></p>
<p><a href="http://www.jianshu.com/p/0c050af6c5ee" target="_blank" rel="external">选择 GCD 还是 NSTimer ？</a></p>
<p><a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="external">iOS 程序员 6 级考试</a></p>
<p><a href="http://www.jianshu.com/p/f28a50f72bb1" target="_blank" rel="external">iOS-多线程详解</a></p>
<p><a href="http://www.jianshu.com/p/e7e44dfb1d2b" target="_blank" rel="external">iOS 线程安全</a></p>
</blockquote>
<h2 id="Before-Everything"><a href="#Before-Everything" class="headerlink" title="Before Everything"></a>Before Everything</h2><h3 id="dispatch-barrier-async与线程安全"><a href="#dispatch-barrier-async与线程安全" class="headerlink" title="dispatch_barrier_async与线程安全"></a><code>dispatch_barrier_async</code>与线程安全</h3><p>据说这样性能更高：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *_name;</div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> _concurrentQueue;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZYPerson</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">       _concurrentQueue = dispatch_queue_create(<span class="string">"com.person.syncQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</div><div class="line">        _name = [name <span class="keyword">copy</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    __block <span class="built_in">NSString</span> *tempName;</div><div class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</div><div class="line">        tempName = _name;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> tempName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="GCD-Timer"><a href="#GCD-Timer" class="headerlink" title="GCD Timer"></a>GCD Timer</h3><p>使用NSTimer，RunLoop实现timer有如下弊端：</p>
<ol>
<li>必须保证有一个活跃的RunLoop，若将逻辑放在子线程执行，子线程RunLoop默认关闭，必须手动激活才能是<code>performSelector</code>和<code>scheduledTimerWithTimeInterva</code>l的调用生效；</li>
<li>NSTimer的创建，撤销必须在同一线程操作，performSelector的创建与撤销必须在同一个线程操作；</li>
<li>容易出现内存泄露，当一个timer被schedule的时候，timer会持有target对象，NSRunLoop对象会持有timer，除了调用invalidate以外没有任何方法可以让NSRunLoop对象会释放对timer的持有，timer会释放对target的持有。</li>
</ol>
<p>一个简单的GCD Timer实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, <span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    dispatch_source_set_event_handler(timer, ^&#123;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_source_set_cancel_handler(timer, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"cancel"</span>);</div><div class="line">        dispatch_release(timer);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//启动timer</span></div><div class="line">    dispatch_resume(timer);</div><div class="line">    <span class="comment">// 取消timer</span></div><div class="line">    dispatch_source_cancel(timer);</div></pre></td></tr></table></figure>
<h3 id="同步与异步，串行与并行"><a href="#同步与异步，串行与并行" class="headerlink" title="同步与异步，串行与并行"></a>同步与异步，串行与并行</h3><table>
<thead>
<tr>
<th></th>
<th>同步执行</th>
<th>异步执行</th>
</tr>
</thead>
<tbody>
<tr>
<td>串行队列</td>
<td>当前线程，一个一个执行</td>
<td>其他线程，一个一个执行</td>
</tr>
<tr>
<td>并行队列</td>
<td>当前线程，一个一个执行</td>
<td>多个线程，一起执行</td>
</tr>
</tbody>
</table>
<h3 id="NSThread-NSOperation-GCD比较"><a href="#NSThread-NSOperation-GCD比较" class="headerlink" title="NSThread,NSOperation,GCD比较"></a>NSThread,NSOperation,GCD比较</h3><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>NSThread</td>
<td>轻量级，相对简单</td>
<td>手动管理所有的线程活动，如生命周期、线程同步、睡眠等</td>
</tr>
<tr>
<td>NSOperation</td>
<td>自带线程周期管理</td>
<td>面向对象，实际使用中代码逻辑很容易被分割</td>
</tr>
<tr>
<td>GCD</td>
<td>最高效，避开并发陷阱</td>
<td>基于C实现，可复用性弱</td>
</tr>
</tbody>
</table>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 <code>NSDictionary</code> 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，<code>NSMutableDictionary</code> 就不是线程安全的，应该保证一次只能有一个线程访问它。</p>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>NSThread 是 OS X 和 iOS 都提供的一个线程对象，它是线程的一个轻量级实现。在执行一些轻量级的简单任务时，NSThread 很有用，但用户仍然需要自己管理线程生命周期，进行线程间同步。比如，线程状态，依赖性，线程间同步等线程相关的主题 NSThread 都没有涉及。比如，涉及到线程间同步仍然需要配合使用 NSLock，NSCondition 或者 @synchronized。所以，遇到复杂任务时，轻量级的 NSThread 可能并不合适。</p>
<ol>
<li>动态实例化</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(loadImageSource:) object:imgUrl];</div><div class="line">thread.threadPriority = <span class="number">1</span>;<span class="comment">// 设置线程的优先级(0.0 - 1.0，1.0最高级)</span></div><div class="line">[thread start];</div></pre></td></tr></table></figure>
<ol>
<li>静态实例化</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(loadImageSource:) toTarget:<span class="keyword">self</span> withObject:imgUrl];</div></pre></td></tr></table></figure>
<ol>
<li>隐式实例化</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(loadImageSource:) withObject:imgUrl];</div></pre></td></tr></table></figure>
<ol>
<li>获取当前线程    </li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *current = [<span class="built_in">NSThread</span> currentThread];</div></pre></td></tr></table></figure>
<ol>
<li>获取主线程  </li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSThread</span> *main = [<span class="built_in">NSThread</span> mainThread];</div></pre></td></tr></table></figure>
<ol>
<li>暂停当前线程  </li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</div></pre></td></tr></table></figure>
<ol>
<li>线程之间通信  </li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在指定线程上执行操作</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) onThread:thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</div><div class="line"><span class="comment">//在主线程上执行操作</span></div><div class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</div><div class="line"><span class="comment">//在当前线程执行操作</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSInvocationOperation</span> *geroge = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span>  </div><div class="line"> selector:<span class="keyword">@selector</span>(run)  object:<span class="string">@"asshole"</span>];</div><div class="line">geroge.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSBlockOperation</span> *blockOperation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class="line">        [<span class="keyword">self</span> run];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">[queue setMaxConcurrentOperationCount:<span class="number">2</span>];</div><div class="line">[queue addOperation:geroge];</div><div class="line">[queue addOperation:totty];</div></pre></td></tr></table></figure>
<p>NSOperation 提供以下任务优先级，以这些优先级设置变量 queuePriority 即可加快或者推迟操作的执行：</p>
<ul>
<li>NSOperationQueuePriorityVeryHigh</li>
<li>NSOperationQueuePriorityHigh</li>
<li>NSOperationQueuePriorityNormal</li>
<li>NSOperationQueuePriorityLow</li>
<li>NSOperationQueuePriorityVeryLow</li>
</ul>
<p>NSOperation 使用状态机模型来表示状态。通常，你可以使用 KVO（Key-Value Observing）观察任务的执行状态。这是其他多线程工具所不具备的功能。NSOperation 提供以下状态：</p>
<ul>
<li>isReady</li>
<li>isExecuting</li>
<li>isFinished</li>
</ul>
<p>NSOperation 对象之间的依赖性可以用如下代码表示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[refreshUIOperation addDependency:requestDataOperation];</div><div class="line">[operationQueue addOperation:requestDataOperation];</div><div class="line">[operationQueue addOperation:refreshUIOperation];</div></pre></td></tr></table></figure>
<p>除非 requestDataOperation 的状态 isFinished 返回 YES，不然 refreshUIOperation 这个操作不会开始。</p>
<p>NSOperation 还有一个非常有用功能，就是“取消”。这是其他多线程工具（包括后面要讲到的 GCD）都没有的。调用 NSOperation 的 cancel: 方法即可取消该任务。当你知道这个任务没有必要再执行下去时，尽早安全地取消它将有利于节省系统资源。</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h3><h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial"</span>, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>
<p><code>DISPATCH_QUEUE_SERIAL</code>或者<code>NULL</code>都表示该队列是串行队列。</p>
<p>可通过<code>dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL)</code>获取当前队列label。</p>
<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>主队列，用于刷新UI操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); <span class="comment">// 获取主队列</span></div></pre></td></tr></table></figure>
<h3 id="Global-Dispatch-Queue"><a href="#Global-Dispatch-Queue" class="headerlink" title="Global Dispatch Queue"></a>Global Dispatch Queue</h3><p>此队列就是整个系统都可以使用的<strong>全局并行队列</strong>，由于所有的应用程序都可以使用该并行队列，没必要自已创建并行队列，只需要获取该队列即可。</p>
<p>该队列有4个执行优先级，分别是高(High)、默认（Default）、低（Low）、后台(Background)。我们可以根据自已的需要把不同的任务追加到各个等级的队列当中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  获取高优先级队列</span></div><div class="line"><span class="comment"> */</span></div><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  获取默认优先级队列</span></div><div class="line"><span class="comment"> */</span></div><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  获取低优先级队列</span></div><div class="line"><span class="comment"> */</span></div><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *  获取后台优先级队列</span></div><div class="line"><span class="comment"> */</span></div><div class="line">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h3 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h3><p>dispatch_set_target的作用是设置一个队列的优先级，我们手动创建的队列，无论是串行队列还是并发队列，都跟默认优先级的全局并发队列具有相同的优先级。如果我们需要改变队列优先级，则可以使用dispatch_set_tartget方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">"MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div><div class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</div></pre></td></tr></table></figure>
<p>上面的代码，<code>dispatch_set_target</code>方法的第一个参数是要设置优先级的队列，第二队参数是则是参考的的队列，使第一个参数与第二个参数具有相同的优先级。</p>
<h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h3><p><strong>在x秒后把任务追加到队列中，并不是在x秒后执行</strong>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"waited at least three seconds."</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h3><h4 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h4><p>向group添加任务队列，当所有的任务都完成后，异步通知任务执行结束。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);  <span class="comment">//获取全局并发队列</span></div><div class="line"></div><div class="line">dispatch_group_t group = dispatch_group_create(); <span class="comment">//创建dispatch_group</span></div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"block 1"</span>));&#125;); <span class="comment">//把任务追加到队列中</span></div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block 2"</span>);&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"block 3"</span>);&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"结束"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"不阻塞"</span>);</div></pre></td></tr></table></figure>
<p>上面的代码，执行结果为:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">不阻塞</div><div class="line">block <span class="number">3</span></div><div class="line">block <span class="number">2</span></div><div class="line">block <span class="number">1</span></div><div class="line">结束</div></pre></td></tr></table></figure>
<p>很明显，这种方式是不阻塞的。由于我们是异步把任务添加到队列中，所以任务执行的顺序是不一定的。但是dispatch_group_notify里面的block肯定是最后执行。</p>
<h4 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h4><p>向group追加任务队列，如果所有的任务都执行或者超时，返回一个long类型的值。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);  <span class="comment">//获取全局并发队列</span></div><div class="line">dispatch_group_t group = dispatch_group_create(); <span class="comment">//创建dispatch_group</span></div><div class="line">dispatch_group_async(group, queue, ^&#123; <span class="built_in">NSLog</span>(<span class="string">@"block 1"</span>));&#125;); <span class="comment">//把任务追加到队列中</span></div><div class="line">dispatch_group_async(group, queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"block 2"</span>);&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">       [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"block 3"</span>);</div><div class="line">&#125;);    </div><div class="line"></div><div class="line"><span class="keyword">long</span> result = dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div><div class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"结束"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"阻塞"</span>);</div></pre></td></tr></table></figure>
<p>执行结果是</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">block <span class="number">1</span></div><div class="line">block <span class="number">2</span>    </div><div class="line">block <span class="number">3</span></div><div class="line">结束</div><div class="line">阻塞</div></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>第一个参数为需要等待的目标调度组，第二个参数则是等待的时间（超时），<code>DISPATCH_TIME_FOREVER</code>，表示永远等待。</p>
<p><code>dispatch_group_wait</code>函数返回值为0，表示里面的所有任务都已经执行（若不为0则表示等待超时）。如果把等待时间改为4秒（dispatch_time(DISPATCH_TIME_NOW, 4ull * NSEC_PER_SEC)），那么因为最后添的那个block，至少需要5秒的时候，才可以执行完毕。那么result返回值则不为0。执行结果为</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">block <span class="number">1</span></div><div class="line">block <span class="number">2</span>    </div><div class="line">阻塞</div><div class="line">block <span class="number">3</span></div></pre></td></tr></table></figure>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><p><code>dispatch_barrier_async</code>就如同它的名字一样，在队列执行的任务中增加“栅栏”，在增加“栅栏”之前已经开始执行的block将会继续执行，当dispatch_barrier_async开始执行的时候其他的block处于等待状态，dispatch_barrier_async的任务执行完后，其后的block才会执行。</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h3><p>如果你需要重复执行同一个任务，<code>dispatch_apply</code>是你最好的选择。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"one"</span>,<span class="string">@"two"</span>,<span class="string">@"three"</span>];</div><div class="line">dispatch_apply(<span class="number">3</span>, queue, ^(size_t index) &#123;</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:index];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array[index]);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"阻塞"</span>);</div></pre></td></tr></table></figure>
<p>上面的代码执行结果是</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">12.354</span> Thread Learn[<span class="number">40330</span>:<span class="number">1678876</span>] one</div><div class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">12.354</span> Thread Learn[<span class="number">40330</span>:<span class="number">1678948</span>] two</div><div class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">12.355</span> Thread Learn[<span class="number">40330</span>:<span class="number">1678965</span>] three</div><div class="line"><span class="number">2015</span><span class="number">-09</span><span class="number">-08</span> <span class="number">22</span>:<span class="number">01</span>:<span class="number">14.357</span> Thread Learn[<span class="number">40330</span>:<span class="number">1678876</span>] 阻塞</div></pre></td></tr></table></figure>
<p>可见<code>dispatch_apply</code>是以同步的方式把任务追加到队列当中，所以一般会在<code>dispatch_async</code>函数中异步执行该函数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//异步执行</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    dispatch_apply(<span class="number">3</span>, queue, ^(size_t index) &#123;</div><div class="line">        <span class="comment">//Do somthing</span></div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="dispatch-suspend-amp-dispatch-resume"><a href="#dispatch-suspend-amp-dispatch-resume" class="headerlink" title="dispatch_suspend &amp; dispatch_resume"></a>dispatch_suspend &amp; dispatch_resume</h3><p><code>dispatch_suspend</code>挂起指定的队列</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_supend(queue);</div></pre></td></tr></table></figure>
<p><code>dispatch_resume</code>恢复指定队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<p>线程挂起对已执行的任务没有影响，挂起后，还未执行的任务停止执行，待恢复后，这些任务继续执行</p>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>可能大家使用dispatch_one生成单例，而很多人都会这样子写</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+(MAMapView *)shareMAMapView&#123;</div><div class="line">    <span class="keyword">static</span> MAMapView *instance = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;predicate,^&#123;</div><div class="line">            instance = [[MAMapView alloc]init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这样写会有问题的，要复写<code>alloWithZone:</code>方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> MAMapView *instance = <span class="literal">nil</span>;</div><div class="line"><span class="comment">//重写allocWithZone保证分配内存alloc相同</span></div><div class="line">+(<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(onceToken, ^&#123;</div><div class="line">        instance = [<span class="keyword">super</span> allocWithZone:zone];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+(MAMapView *)shareMAMapView&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> predicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;predicate,^&#123;</div><div class="line">        instance = [[MAMapView alloc]init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"><span class="comment">//保证copy相同</span></div><div class="line">-(<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h3><p>在GCD中有三个函数是semaphore的操作，分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Method</th>
<th>Bref</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dispatch_semaphore_create</td>
<td>创建一个semaphore</td>
</tr>
<tr>
<td style="text-align:left">dispatch_semaphore_signal</td>
<td>发送一个信号，信号量加1</td>
</tr>
<tr>
<td style="text-align:left">dispatch_semaphore_wait</td>
<td>等待信号，&lt;0时一直等待,否则正常执行，并且-1</td>
</tr>
</tbody>
</table>
<p>可以通过信号量来创建一个并发控制来同步任务和有限资源访问控制。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();   </div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">10</span>);   </div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)   </div><div class="line">    &#123;   </div><div class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);   </div><div class="line">        dispatch_group_async(group, queue, ^&#123;   </div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,i);   </div><div class="line">            sleep(<span class="number">2</span>);   </div><div class="line">            dispatch_semaphore_signal(semaphore);   </div><div class="line">        &#125;);   </div><div class="line">    &#125;   </div><div class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<p>运行结果：每2秒执行10此。</p>

      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/iOS/">iOS</a>
            
              <a href="/tags/MultiThread/">MultiThread</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/05/19/iOS/Memory-Management/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Memory Management</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2016/04/10/iOS/FrameWork/">
        <span class="next-text nav-default">FrameWork</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:nic.reals@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/nicreals" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Nic Reals</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
